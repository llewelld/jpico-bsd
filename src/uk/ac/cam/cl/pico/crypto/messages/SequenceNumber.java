/**
 * Copyright Pico project, 2016
 */

package uk.ac.cam.cl.pico.crypto.messages;

import java.math.BigInteger;
import java.security.SecureRandom;

import com.google.common.base.Objects;

/**
 * SequenceNumber exists to ensure that the mutual authentication between the Pico and the Service
 * is current, it prevents replay attacks.
 * 
 * Underneath, it is an incrementing bit string which is sent in the encrypted part of the
 * {@link EncPicoReauthMessage} and {@link EncServiceReauthMessage}, and both sides verify and then
 * respond to the sequence number.
 * 
 * @author cw471
 * 
 */
public final class SequenceNumber {

    /** Challenge length in bytes */
    private static final int SEQUENCE_NUMBER_LENGTH = 32;

    private final BigInteger sequenceNumber;

    /* ********************** Create a new Challenge ********************** */

    SequenceNumber(final BigInteger sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
    }

    /**
     * Generates a new sequence number, using a SecureRandom.
     * 
     * @return
     */
    public static SequenceNumber getRandomInstance() {
        byte[] sequenceNumberBytes = new byte[SEQUENCE_NUMBER_LENGTH];
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(sequenceNumberBytes);
        // Interpret sequenceNumberBytes as magnitude of the BigInteger,
        // so it is always positive or zero.
        BigInteger sequenceNumber = new BigInteger(1, sequenceNumberBytes);
        return new SequenceNumber(sequenceNumber);
    }

    /* *********************** Respond to a sequence number *********************** */

    /**
     * Returns a new sequence number, which is used both as the response to the previous sequence
     * number from the other side and the next sequence number for the other side to respond to.
     * 
     * @return The response to this sequence number.
     */
    public SequenceNumber getResponse() {
        return new SequenceNumber(getIncrementedChallenge());
    }

    /**
     * Check that a response to the current sequence number by the other party is valid.
     * 
     * @param cr The response to be tested.
     * @return true if the response was correct, false otherwise/
     */
    public boolean verifyResponse(SequenceNumber cr) {
        return cr.sequenceNumber.equals(getIncrementedChallenge());
    }

    /* *************************** Helper methods *************************** */

    private BigInteger getIncrementedChallenge() {
        BigInteger addedOne = sequenceNumber.add(BigInteger.ONE);
        // Check if we need to wrap back to zero.
        byte[] addedOneBytes = addedOne.toByteArray();
        if (addedOneBytes.length > SEQUENCE_NUMBER_LENGTH && addedOneBytes[0] != 0) {
            // Wrap around internal state to match external output.
            return BigInteger.ZERO;
        } else {
            return addedOne;
        }
    }

    /* ************************ Object Methods ************************ */

    /**
     * Compares to sequence numbers.
     */
    @Override
    public boolean equals(Object o) {
        if (o instanceof SequenceNumber) {
            return sequenceNumber.equals(((SequenceNumber) o).sequenceNumber);
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(sequenceNumber);
    }
    
    @Override
    public String toString() {
        return sequenceNumber.toString();
    }

    /* *********************** Serialisation Methods *********************** */

    /**
     * Makes a SequenceNumber object from a byte array, as included in the encrypted byte stream in
     * the {@link PicoReauthMessage} and {@link ServiceReauthMessage}.
     * 
     * @param sequence numberByteArray The byte array representation of the sequence number, as
     *        generated by {@link toByteArray()}.
     * @return The SequenceNumber constructed from that byte array.
     */
    public static SequenceNumber fromByteArray(byte[] sequenceNumberByteArray) {
        // Force non-two's complement interpretation of the bits.
        return new SequenceNumber(new BigInteger(1, sequenceNumberByteArray));
    }

    /**
     * Serialise this sequence number into a byte array to be sent as part of the encrypted byte
     * stream in {@link PicoReauthMessage} and {@link ServiceReauthMessage}.
     * 
     * The sequence number can be reconstructed by {@link SequenceNumber#fromByteArray(byte[])}.
     * 
     * @return The byte array representation of this sequence number.
     */
    public byte[] toByteArray() {
        byte[] bigIntBytes = sequenceNumber.toByteArray();
        byte[] bytes = new byte[SEQUENCE_NUMBER_LENGTH];
        int bytesToCopy = Math.min(bigIntBytes.length, SEQUENCE_NUMBER_LENGTH);
        // Copy bytesToCopy bits from the end of bigIntBytes, and output to
        // the end of bytes.

        // Both are needed as the output from BigInt's toByteArray could be
        // short (i.e. the number is low) or too long (i.e. the number is in
        // the upper half of the representation)
        System.arraycopy(
                bigIntBytes,
                bigIntBytes.length - bytesToCopy,
                bytes,
                SEQUENCE_NUMBER_LENGTH - bytesToCopy,
                bytesToCopy);
        return bytes;
    }
}